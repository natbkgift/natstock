# A1: สคีมาหลายล็อต + ระบบเลขรันอัตโนมัติ (SKU/LOT)

## โครงสร้างฐานข้อมูลที่เกี่ยวข้อง

| ตาราง | คีย์หลัก/ดัชนี | รายละเอียด | หมายเหตุ |
|-------|-----------------|-------------|----------|
| `product_batches` | `id`, `unique(product_id, lot_no)`, `index(product_id, expire_date)` | เก็บข้อมูลล็อตของสินค้า (`lot_no`, `qty`, `expire_date`, `received_at`, `is_active`, `note`) | ลบสินค้าแล้วลบล็อตทั้งหมดแบบ cascade |
| `stock_movements` | FK `batch_id` (nullable) | เก็บการเคลื่อนไหวของสต๊อกและผูกกับล็อต ถ้าล็อตถูกลบจะตั้งเป็น `null` อัตโนมัติ | ต้องผูกกับการเคลื่อนไหวทุกประเภทภายหลัง |
| `products` | `unique(sku)` | ยังเก็บคอลัมน์ราคา/จำนวนเดิมไว้ เผื่อใช้อ้างอิงย้อนหลัง | หลัง backfill ยอดจริงต้องอ่านจาก `product_batches` |
| `sequences` | `key` (PK), `next_val` | ใช้เก็บเลขรัน global เช่น `SKU` | seed เริ่มต้น `('SKU', 1)` |
| `product_lot_counters` | `product_id` (PK/FK), `next_no` | ติดตามเลขล็อตถัดไปของสินค้าแต่ละตัว | ค่าเริ่มต้น `1` เพื่อให้สร้าง `LOT-01` ได้ |

> ⚠️ ห้ามลบคอลัมน์ราคาจากฐานข้อมูล แม้ระบบจะไม่ใช้งานใน UI/รายงานก็ตาม

## บริการเลขรัน

- `SkuService::next()` — ทำงานในทรานแซกชันพร้อม `SELECT ... FOR UPDATE` เพื่อรับประกันว่าเลข `SKU-0001`, `SKU-0002`, ... จะไม่ชนกันแม้มีการเรียกพร้อมกันหลายคำสั่ง
- `LotService::nextFor(Product $product)` — ใช้ `product_lot_counters` เพื่อนับ `LOT-01`, `LOT-02`, ... ต่อสินค้า พร้อมสร้างแถว counter ให้อัตโนมัติหากยังไม่มีข้อมูล
- โมเดล `Product` จะสร้างล็อตตั้งต้น `LOT-01` (qty = 0) ในเหตุการณ์ `created` เสมอ จากนั้นตั้ง `next_no = 2`

## คำสั่ง Backfill

ใช้คำสั่ง `php artisan backfill:product-batches` เพื่อย้ายข้อมูลเก่าเข้าสู่โครงสร้างล็อตแบบใหม่

1. เตรียมระบบให้พร้อม (งดใช้งาน, สำรองข้อมูล)
2. รัน `php artisan migrate --force`
3. รัน `php artisan backfill:product-batches`
   - กำหนด SKU ให้สินค้าที่เว้นว่าง
   - ย้ายยอด `products.qty > 0` ไปสร้างล็อต `LOT-01` พร้อมตั้ง `received_at` เป็นเวลาปัจจุบัน
   - ตั้งค่า `product_lot_counters.next_no = 2` และรีเซ็ต `products.qty = 0`
4. ตรวจสอบผลลัพธ์ผ่านรายงานหรือตารางโดยตรง (ปริมาณรวมต้องเท่ากับก่อน backfill)

> ℹ️ **ข้อควรระวัง:** คำสั่ง backfill ประมวลผลสินค้าเป็นชุดย่อย (`chunkById`) และห่อแต่ละสินค้าด้วย `DB::transaction()` แยกกัน หากเกิด `RuntimeException` หลังมีสินค้าบางรายการย้ายข้อมูลแล้ว การเปลี่ยนแปลงก่อนหน้าจะถูก commit ไปแล้ว ในขณะที่สินค้าที่เหลือจะไม่ถูกอัปเดต จำเป็นต้องตรวจสอบและปรับยอดด้วยตนเองกรณีผิดพลาดกลางคัน

## แนวทางตรวจสอบหลังไมเกรชัน

- สินค้าที่สร้างใหม่จะได้ `SKU-####` และมีล็อต `LOT-01` ให้อัตโนมัติ
- `Product::qtyCurrent()` ต้องให้ค่าตรงกับยอดรวมของล็อตที่ `is_active = 1`
- ทดสอบคำสั่ง backfill บน staging ด้วยข้อมูลจำลองก่อนใช้งานจริง

## Rollback คร่าว ๆ (ใช้เฉพาะกรณีจำเป็น)

1. รวมยอดจาก `product_batches` (เฉพาะ `is_active = 1`) กลับไปยัง `products.qty` แล้วบันทึกหลักฐานก่อนแก้ไข
2. ตรวจสอบระบบที่เชื่อมต่อ (รายงาน, สคริปต์นำเข้า/ส่งออก, BatchResolver) ให้พร้อมหยุดใช้งาน เพราะข้อมูลล็อตจะไม่พร้อมหลัง rollback
3. สำรองฐานข้อมูลเต็มชุด จากนั้นจึง `php artisan migrate:rollback` ทีละสเต็ปตามลำดับย้อนกลับ
4. ตรวจสอบว่ามีสต๊อกที่ถูก backfill ไปบางส่วนหรือไม่ ถ้ามีให้เทียบกับรายงานก่อน rollback และแก้ไขด้วยสคริปต์/SQL ตามบันทึกหลักฐาน

> ❗ Rollback มีความเสี่ยงสูง ต้องปิดระบบชั่วคราว ประสานทีมปฏิบัติการ และทำตามขั้นตอนในเอกสาร recovery (เช่น `ops/recovery/rollback_A1_schema.md`) อย่างเคร่งครัด
